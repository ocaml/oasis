# Function library for OASIS builds.

if $(not $(defined CMXS_ENABLED))
    CMXS_ENABLED = false
    export

if $(not $(defined OCAMLMKLIB))
    OCAMLMKLIB = ocamlmklib
    export

if $(not $(defined OCAMLMKLIBFLAGS))
    OCAMLMKLIBFLAGS =
    export

if $(not $(defined OCAML_LIB_CCLIB))
    OCAML_LIB_CCLIB =
    export

if $(not $(defined OCAML_LIB_DLLIB))
    OCAML_LIB_DLLIB =
    export

if $(not $(defined OCAML_LIB_DLLPATH))
    OCAML_LIB_DLLPATH =
    export

if $(not $(defined OCAML_LINK_CCLIB))
    OCAML_LINK_CCLIB =
    export

if $(not $(defined OCAML_LINK_DLLIB))
    OCAML_LINK_DLLIB =
    export

if $(not $(defined OCAML_LINK_DLLPATH))
    OCAML_LINK_DLLPATH =
    export


OASIS_clean_list[] =
    *.cmi
    *.cmt
    *.cmti
    *.cmo
    *.cma
    *.cmx
    *$(EXT_OBJ)
    *.cmxa
    *$(EXT_LIB)
    *.so
    *.cmxs

OASIS_distclean_list[] =
    $(OASIS_clean_list)


# Returns the empty array

OASIS_empty_array[] =

# OASIS_getvar(v) gets the contents of the (array) variable named v, or
# the empty array if it is not defined. If the variable NAME is defined
# in the context where this function is called, it is first looked at
# the variable v_$(NAME), and this variable is taken instead.

OASIS_getvar(name) =
    declare private.v
    if $(and $(defined NAME) $(defined $(name)_$(NAME)))
        v = $(getvar $(name)_$(NAME))
        export v
    else
        if $(defined $(name))
            v = $(getvar $(name))
            export v
        else
            v = $(OASIS_empty_array)
            export v
        export v
    value $(apply $(v))


OASIS_run(list) =
    run_it(f) =
        value $(f)
    foreach($(run_it), $(list))

OASIS_target_OCamlLibrary(name) =
    value $(array $(if $(NATIVE_ENABLED), $(array $(name).cmxa, $(name)$(EXT_LIB))), $(if $(and $(NATIVE_ENABLED), $(CMXS_ENABLED)), $(name).cmxs), $(if $(BYTE_ENABLED), $(name).cma))

# Extensions compared to OCamlLibrary:
#  - OCAML_LIBS and OCAML_CLIBS are now dependencies
#  - creates the cmxs if CMXS_ENABLED
#  - ignores OCAMLPACKS (no relinking of packages)
#  - can link in c_objects

OASIS_build_OCamlLibrary(name,modules,c_objects) =
    private.name = $(file $(name))

    private.OFILES   = $(addsuffix $(EXT_OBJ), $(modules))
    private.CMOFILES = $(addsuffix .cmo, $(modules))
    private.CMXFILES = $(addsuffix .cmx, $(modules))

    private.CLIB      = $(file $(name)$(EXT_LIB))
    private.BYTELIB   = $(file $(name).cma)
    private.NATIVELIB = $(file $(name).cmxa)
    private.LIBNAME   = $(file $(name))

    private.CMXSFILE  = $(file $(name).cmxs)
    private.C_OBJECTS = $(file $(c_objects))
    private.STUBS     = $(LIBNAME)_stubs

    private.BYTEDEPS   = $(addsuffix .cma, $(OCAML_LIBS))
    private.NATIVEDEPS = $(addsuffix .cmxa, $(OCAML_LIBS))
    private.CLIBDEPS   = $(addsuffix $(EXT_LIB), $(OCAML_LIBS))

    #
    # Link commands
    #
    if $(gt $(length $(C_OBJECTS)), 0)
        private.flags =
        private.byteflags =
        private.natflags =
        if $(gt $(length $(OCAML_LIB_FLAGS)), 0)
            flags = -ccopt $(quote $(OCAML_LIB_FLAGS))
            export flags
        if $(gt $(length $(OCAMLCFLAGS)), 0)
            byteflags = -ccopt $(quote $(OCAMLCFLAGS))
            export byteflags
        if $(gt $(length $(OCAMLOPTFLAGS)), 0)
            natflags = -ccopt $(quote $(OCAMLOPTFLAGS))
            export natflags
        if $(gt $(length $(OCAML_LIB_DLLIB)), 0)
            byteflags = -cclib $(quote $(addprefix -dllib, $(OCAML_LIB_DLLIB)))
            export byteflags
        if $(gt $(length $(OCAML_LIB_DLLPATH)), 0)
            byteflags = -dllpath $(OCAML_LIB_DLLPATH)
            export byteflags

        $(BYTELIB): $(CMOFILES) $(C_OBJECTS) $(BYTEDEPS)
            $(OCAMLMKLIB) \
                 $(OCAML_LIB_CCLIB) $(flags) $(byteflags) \
                 -ocamlc "$(OCAMLC)" \
                 -o $(LIBNAME) -oc $(STUBS) \
                 $(OCamlLinkSort $(CMOFILES)) $(C_OBJECTS)

        $(NATIVELIB) $(CLIB): $(CMXFILES) $(OFILES) $(C_OBJECTS) $(NATIVEDEPS) $(CLIBDEPS)
            $(OCAMLMKLIB) \
                 $(OCAML_LIB_CCLIB) $(flags) $(natflags) \
                 -ocamlopt "$(OCAMLOPT)" \
                 -o $(LIBNAME) -oc $(STUBS) \
                 $(OCamlLinkSort $(CMXFILES)) $(C_OBJECTS)
    else
        private.flags =
        private.byteflags =
        if $(gt $(length $(OCAML_LIB_CCLIB)), 0)
            flags += -cclib $(quote $(OCAML_LIB_CCLIB))
            export flags
        if $(gt $(length $(OCAML_LIB_DLLIB)), 0)
            byteflags += -dllib $(quote $(OCAML_LIB_DLLIB))
            export byteflags
        if $(gt $(length $(OCAML_LIB_DLLPATH)), 0)
            byteflags += -dllpath $(quote $(OCAML_LIB_DLLPATH))
            export byteflags

        $(BYTELIB): $(CMOFILES) $(BYTEDEPS)
            $(OCAMLLINK) -a \
                 -o $(BYTELIB) $(OCAMLCFLAGS) \
                 $(flags) $(OCAML_LIB_FLAGS) \
                 $(OCamlLinkSort $(CMOFILES))

        $(NATIVELIB) $(CLIB): $(CMXFILES) $(OFILES) $(NATIVEDEPS) $(CLIBDEPS)
            $(OCAMLOPTLINK) -a \
                 -o $(NATIVELIB) $(OCAMLOPTFLAGS) \
                 $(flags) $(OCAML_LIB_FLAGS) \
                 $(OCamlLinkSort $(CMXFILES))

    $(CMXSFILE): $(NATIVELIB) $(CLIB)
        $(OCAMLOPTLINK) -shared -cclib -L. -o $(CMXSFILE) $(NATIVELIB)

    return $(array $(if $(NATIVE_ENABLED), $(NATIVELIB)), $(if $(NATIVE_ENABLED), $(CLIB)), $(if $(and $(NATIVE_ENABLED), $(CMXS_ENABLED)), $(CMXSFILE)), $(if $(BYTE_ENABLED), $(BYTELIB)))


OASIS_target_OCamlExecutable(name) =
    value $(name)

# The difference to OCamlProgram is that OASIS_build_OCamlExecutable figures
# the modules of the program automatically out. You just need to pass in the
# name of the main module.
# Also:
#  - can link in c_objects

OASIS_build_OCamlExecutable(name,mainmodule,c_objects) =
    private.get_byte_deps(cmofile, cmafiles) =
        private.all_cmodeps = $(dependencies-all cmofile)
        private.cmo_cmodeps = $(filter .cmo, $(all_cmodeps))
        private.all_cmadeps = $(dependencies-all cmafiles)
        private.cmo_cmadeps = $(filter .cmo, $(all_cmadeps))
        value $(set $(set-diff $(cmo_cmodeps), $(cmo_cmadeps)))

    private.get_native_deps(cmxfile, cmxafiles) =
        private.all_cmxdeps = $(dependencies-all cmxfile)
        private.cmx_cmxdeps = $(filter .cmx, $(all_cmxdeps))
        private.all_cmxadeps = $(dependencies-all cmxafiles)
        private.cmx_cmxadeps = $(filter .cmx, $(all_cmxadeps))
        value $(set $(set-diff $(cmx_cmxdeps), $(cmx_cmxadeps)))

    private.CMOFILE   = $(addsuffix .cmo, $(mainmodule))
    private.CMXFILE   = $(addsuffix .cmx, $(mainmodule))
    private.OFILE     = $(addsuffix $(EXT_OBJ), $(mainmodule))

    private.CMAFILES  = $(addsuffix .cma,  $(OCAML_LIBS))
    private.CMXAFILES = $(addsuffix .cmxa, $(OCAML_LIBS))
    private.ARFILES   = $(addsuffix $(EXT_LIB), $(OCAML_LIBS))
    private.CMA_OTHER_FILES = $(addsuffix .cma, $(OCAML_OTHER_LIBS))
    private.CMXA_OTHER_FILES = $(addsuffix .cmxa, $(OCAML_OTHER_LIBS))

    private.CLIBS = $(addsuffix $(EXT_LIB), $(OCAML_CLIBS))
    private.C_OBJECTS = $(file $(c_objects))

    private.name = $(file $(name))

    private.PROG     = $(file $(name)$(EXE))
    private.BYTEPROG = $(file $(name).run)
    private.OPTPROG  = $(file $(name).opt)

    private.flags =
    private.byteflags =
    if $(gt $(length $(OCAML_LINK_CCLIB)), 0)
        flags += -cclib $(quote $(OCAML_LINK_CCLIB))
        export flags
    if $(gt $(length $(OCAML_LINK_DLLIB)), 0)
        byteflags += -dllib $(quote $(OCAML_LINK_DLLIB))
        export byteflags
    if $(gt $(length $(OCAML_LINK_DLLPATH)), 0)
        byteflags += -dllpath $(quote $(OCAML_LINK_DLLPATH))
        export byteflags

    #
    # Rules to build byte-code and native targets
    #
    $(BYTEPROG): $(CMAFILES) $(CMOFILE) $(CLIBS) $(C_OBJECTS)
        $(OCAMLFIND) $(OCAMLLINK) $(LAZY_OCAMLFINDFLAGS) $(PREFIXED_OCAMLPACKS) $(OCAMLFLAGS) $(OCAMLCFLAGS)\
                 $(PREFIXED_OCAMLINCLUDES) $(OCAML_BYTE_LINK_FLAGS) \
                 $(byteflags) $(flags) \
                 -o $@ $(CMA_OTHER_FILES) $(CMAFILES) \
                 $(OCamlLinkSort $(get_byte_deps $(CMOFILE), $(CMAFILES)) $(CMOFILE)) \
                 $(C_OBJECTS) $(CLIBS) $(OCAML_LINK_FLAGS)

    $(OPTPROG): $(CMXAFILES) $(ARFILES) $(CMXFILE) $(OFILE) $(CLIBS) $(C_OBJECTS)
         $(OCAMLFIND) $(OCAMLOPTLINK) $(LAZY_OCAMLFINDFLAGS) $(PREFIXED_OCAMLPACKS) $(OCAMLFLAGS) $(OCAMLOPTFLAGS)\
                 $(PREFIXED_OCAMLINCLUDES) $(OCAML_NATIVE_LINK_FLAGS)\
                 $(flags) \
                 -o $@ $(CMXA_OTHER_FILES) $(CMXAFILES) \
                 $(OCamlLinkSort $(get_native_deps $(CMXFILE), $(CMXAFILES)) $(CMXFILE)) \
                 $(C_OBJECTS) $(CLIBS) $(OCAML_LINK_FLAGS)

    #
    # Link the actual executables.
    # Always prefer native executables.
    #
    if $(NATIVE_ENABLED)
        $(PROG): $(OPTPROG)
            ln-or-cp $< $@
    elseif $(BYTE_ENABLED)
        $(PROG): $(BYTEPROG)
            ln-or-cp $< $@
    else
        err. =
            extends $(UnbuildableException)
            message = $(string $"Cannot build $(PROG) because neither bytecode nor native code is enabled")
        raise($(err))
    return $(array $(PROG), $(if $(NATIVE_ENABLED), $(OPTPROG)), $(if $(BYTE_ENABLED), $(BYTEPROG)))


# Reading in setup.data

private.to_hex_digit(n) =
    if $(eq $(n), 10)
        return a
    elseif $(eq $(n), 11)
        return b
    elseif $(eq $(n), 12)
        return c
    elseif $(eq $(n), 13)
        return d
    elseif $(eq $(n), 14)
        return e
    elseif $(eq $(n), 15)
        return f
    else
        return $(string $(n))

private.char(code) =
    d1 = $(div $(code) 16)
    d2 = $(mod $(code) 16)
    return $(unhexify $(string $(to_hex_digit $(d1))$(to_hex_digit $(d2))))

private.string_lexer() =
    lexer. =
        extends $(Lexer)

        declare lex
        declare rule

        buffer[] =

        other: .
            buffer[] += $0
            lex()

        eof: $"\'"
            err. =
                extends $(Exception)
                message = $"Unterminated string, location: $(string-of-location $(parse-loc))"
            raise $(err)

        chars: $'[^\\"]+'
            buffer[] += $0
            lex()

        string-end: $'"'
            Token.pair(string, $(concat $(string), $(buffer)))

        esc1: $'\\\\'
            buffer[] += \\
            lex()

        esc2: $"\\'"
            buffer[] += \'
            lex()

        esc3: $'\\"'
            buffer[] += \"
            lex()

        esc4: $'\\n'
            buffer[] += $(unhexify 0a)
            lex()

        esc5: $'\\t'
            buffer[] += $(unhexify 09)
            lex()

        esc6: $'\\b'
            buffer[] += $(unhexify 07)
            lex()

        esc7: $'\\r'
            buffer[] += $(unhexify 0d)
            lex()

        esc8: $'\\ '
            buffer[] += \ 
            lex()

        esc9: $'\\\([0-7]\)\([0-7]\)\([0-7]\)'
            # Work around an omake-0.9.8.6 bug
            if $(defined 4)
                d1 = $2
                d2 = $3
                d3 = $4
                export d1 d2 d3
            else
                d1 = $1
                d2 = $2
                d3 = $3
                export d1 d2 d3
            code = $(add $(add $(mul $(int $(d1)) 64) $(mul $(int $(d2)) 8)) $(int $(d3)))
            buffer[] += $(char $(code))
            lex()

        esc10: $'\\x\([0-9a-fA-F][0-9a-fA-F]\)'
            buffer[] += $(unhexify $1)
            lex()

        newline: $'(\n|\r\n)'
            buffer[] += $(unhexify 0a)
            lex()

    return $(lexer)
        

private.main_lexer() =
    lexer. =
        extends $(Lexer)

        declare lex
        declare rule

        other: .
            err. =
                extends $(Exception)
                message = $"Lexing error, location: $(string-of-location $(parse-loc))"
            raise $(err)

        white: $'[ \r\n\t]+'
            lex()

        ident: $"[a-zA-Z0-9_']+"
            Token.pair(ident, $0)

        equal: =
            Token.unit(equal)

        string: $'"'
            slexer = $(string_lexer)
            slexer.lex-channel($(channel))

        eof: $"\'"
            Token.unit(eof)

    return $(lexer)


param_lexer() =
    private.dollar = \$
    lexer. =
        extends $(Lexer)

        declare lex
        declare rule

        buffer[] =

        other: .
            err. =
                extends $(Exception)
                message = $"Lexing error, location: $(string-of-location $(parse-loc))"
            raise $(err)

        dollar1: $"\$(dollar)\([a-zA-Z0-9_]+\)"
            declare private.ident
            declare private.varname
            # omake-0.9.8.6 bug
            if $(defined 4)
                ident = $4
                export ident
            else
                ident = $1
                export ident
            varname = $"oasis_$(ident)"
            buffer += $"$(dollar)(apply $(dollar)(getvar $(string-escaped $(varname))))"
            lex()

        dollar2: $"\$(dollar)[(]\([^)]+\)[)]"
            declare private.ident
            declare private.varname
            # omake-0.9.8.6 bug
            if $(defined 3)
                ident = $3
                export ident
            else
                ident = $1
                export ident
            varname = $"oasis_$(ident)"
            buffer += $"$(dollar)(apply $(dollar)(getvar $(string-escaped $(varname))))"
            lex()

        dollar3: $"\$(dollar)[{]\([^)]+\)[}]"
            declare private.ident
            declare private.varname
            # omake-0.9.8.6 bug
            if $(defined 2)
                ident = $2
                export ident
            else
                ident = $1
                export ident
            varname = $"oasis_$(ident)"
            buffer += $"$(dollar)(apply $(dollar)(getvar $(string-escaped $(varname))))"
            lex()

        esc: $"\\\(.\)"
            declare private.data
            data = $1
            buffer += $(string-escaped $(data))
            lex()

        regular: $"[^\\$(dollar)]+"
            declare private.data
            data = $0
            buffer += $(string-escaped $(data))
            lex()

        eof: $"\'"
            value $(concat $(string), $(buffer))


private.parse_error(loc) =
    err. =
        extends $(Exception)
        message = $"Parse error, location: $(string-of-location $(loc))"
    value $(err)


OASIS_convert_env(inchannel,outchannel) =
    private.lexer = $(main_lexer)
    # omake-0.9.8.6 bug: "while" condition is not evaluated at all
    while true
        private.tok = $(lexer.lex-channel $(inchannel))
        if $(equal $(tok.name), eof)
            value $(break)
        elseif $(equal $(tok.name), ident)
            private.ident = $(tok.val)
            tok = $(lexer.lex-channel $(inchannel))
            if $(not $(equal $(tok.name), equal))
                raise $(parse_error $(tok.loc))
            tok = $(lexer.lex-channel $(inchannel))
            if $(not $(equal $(tok.name), string))
                raise $(parse_error $(tok.loc))
            private.val = $(tok.val)
            private.plexer = $(param_lexer)
            private.omakecode = $(plexer.lex-channel $(open-in-string $(val)))
            fprintln($(outchannel), $"oasis_$(string-escaped $(ident))() =")
            fprintln($(outchannel), $"    value $(omakecode)")
        else
            raise $(parse_error $(tok.loc))


OASIS_generate_setup() =
    private.inch = $(fopen setup.data, r)
    private.outch = $(fopen _oasis_setup.om, w)
    OASIS_convert_env($(inch), $(outch))
    fprintln($(outch), $'USE_OCAMLFIND = true')
    fprintln($(outch), $'BYTE_ENABLED = true')
    fprintln($(outch), $'NATIVE_ENABLED = $(OCAMLOPT_EXISTS)')
    fprintln($(outch), $'OCAMLDEP_MODULES_ENABLED = true')
    fprintln($(outch), $'CMXS_ENABLED = $(oasis_native_dynlink)')
    fprintln($(outch), $'OCAMLFLAGS = -g')
    fprintln($(outch), $'INCLUDES = $(oasis_standard_library)')
    fprintln($(outch), $'CC = $(nth-hd 1, $(split $(oasis_bytecomp_c_compiler)))')
    fprintln($(outch), $'CFLAGS = $(nth-tl 1, $(split $(oasis_bytecomp_c_compiler)))')
    close($(inch))
    flush($(outch))
    close($(outch))
